\section{GraphDB}\label{sec:graphdb}
This section will cover GraphDB, the graph database used in this project. It will also cover the creation of the dataset used in this project.

When choosing which database to use, there were some options we had to consider. First, we had to decide if we wanted to use a triplestore or a graph database; a triplestore is a type of graph database specific to working with triples, hence the name~\cite{ontotext-RDF-triplestore}. We also had to consider what we needed to use the database for. There were many popular choices. ~ \cite{best-graph-databases} mentions many popular graph databases and lists some of the pros and cons of each, such as Neo4j, Stardog, ArangoDB, and GraphDB. At first, Neo4j was considered, as it was often mentioned in the literature we read, but since it is not a triple store, it is not directly able to use the SPARQL query language~\cite{neo4j:-a-reasonable-RDF-graph-database}. Instead, we would have to learn to use Cypher, Neo4j's graph query language~\cite{cypher-query-language}, or translate a SPARQL query to Cypher.

Instead, we chose to use GraphDB, a triplestore compliant with W3C standards and uses the SPARQL query language. As described by the creators of GraphDB: \cite{graphDB}{GraphDB is an enterprise ready Semantic Graph Database, compliant with W3C Standards. Semantic graph databases (also called RDF triplestores) provide the core infrastructure for solutions where modelling agility, data integration, relationship exploration and cross-enterprise data publishing and consumption are important.}
Additionally, GraphDB was free for the purposes we needed, and it was easy to set up and use, making it a good choice for our project.

Upon choosing a database to work with, we used docker to set up a local instance of GraphDB. By doing this, we could easily manage and use our dataset for testing purposes. We used the guide provided by GraphDB~\cite{docker-graphDB} and followed the steps to set up a local instance of GraphDB.

The first step was to install docker, which was done from their website~\cite{docker-install}. Then we pulled the GraphDB image from docker hub~\cite{docker-graphDB} and started the container using the command "docker run -p 127.0.0.1:7200:7200 --name graphdb-instance-name -t ontotext/graphdb:tag", replacing the name "graphdb-instance-name" with "Pokemon-DB" and the tag to the newest version, which at the time was "10.2.0". After this, we could access the GraphDB instance from our browser by going to "http://localhost:7200/repositories". We could then create a new repository and start using the database. GraphDB has a built-in user interface, which makes it easy to run SPARQL queries and view imported data as a visual representation. We will cover the creation of the dataset in the next section.

\subsection{Dataset}\label{sec:dataset}
We could import a dataset with the database set up and ready for use. We debated whether to use a pre-existing dataset or create our own. We searched for different options of pre-existing datasets but realised that most were too large or too complex for our purposes. Therefore we decided to create our dataset. We wanted to create a small, simple dataset, and additionally, we wanted to get a better understanding of how \gls{rdf} worked. The dataset was made in a .ttl file, a format that stores \gls{rdf} data. The file was then imported into GraphDB.
We based the dataset on Pokemon for no reason other than being easy to understand and relate to. Therefore, we created a dataset with the first 151 Pokemon, where each Pokemon had a name, one or two types, a number, and a relationship to other Pokemon that it evolved to. We felt this was a good representation of the concept of \gls{rdf}.