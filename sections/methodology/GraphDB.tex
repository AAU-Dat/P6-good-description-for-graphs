\section{GraphDB}\label{sec:graphdb}
This section will cover use of GraphDB, the graph database used in this project. It will also cover the creation of the dataset used in this project.

When choosing which database to use, there were some options we had to consider. We had to decide if we wanted to use a triplestore or a graph database\task{Include a small paragraph describing the differences between triplestroe and graph database}, and what we needed to use the database for etc. There were many popular choices, ~\cite{best-graph-databases} mentions many popular graph databases, and lists some of the pros and cons of each, such as Neo4j, Stardog, ArangoDB, and GraphDB. At first Neo4j was considered, as it was often mentioned in the literature we read, but since it is not a triple store, it is not direclty able to use the SPARQL query language~\cite{neo4j:-a-reasonable-RDF-graph-database}. Instead we would have to learn how to use Cypher, Neo4j's graph query language~\cite{cypher-query-language}, or alternativly translate a SPARQL query to Cypher.

Instead we chose to use GraphDB, as it is a triplestore that is compliant with W3C standards, and uses the SPARQL query language. As described by the creators of GraphDB: \cite{graphDB}{GraphDB is an enterprise ready Semantic Graph Database, compliant with W3C Standards. Semantic graph databases (also called RDF triplestores) provide the core infrastructure for solutions where modelling agility, data integration, relationship exploration and cross-enterprise data publishing and consumption are important.}
Additionally, GraphDB was free for the purposes we needed it for, and it was easy to setup and use, making it a good choice for our project.

Upon choosing a database to work with, we used docker, to setup a local instance of GraphDB, by doing this, we could easily manage our dataset, and use it for testing purposes. We simply used the guide provided by GraphDB~\cite{docker-graphDB}, and followed the steps to setup a local instance of GraphDB.
First step was to install docker, which was done from their website~\cite{docker-install}. Then we pulled the GraphDB image from docker hub~\cite{docker-graphDB}, and started the container using the command "docker run -p 127.0.0.1:7200:7200 --name graphdb-instance-name -t ontotext/graphdb:tag", replacing the name "graphdb-instance-name" with "Pokemon-DB" and the tag to the newest version, which at the time was "10.2.0". After this we could access the GraphDB instance from our browser, by going to "http://localhost:7200/repositories". We could then create a new repository, and start using the database. GraphDB has a built in user interface, which made it easy to run SPARQL queries, to view imported data. We will cover the creation of the dataset in the next section.

\subsection{Dataset}\label{sec:dataset}
With the database set up and ready for use, we were able to import a dataset. We debated on whether to use a pre-existing dataset, or create our own. We searched for different options of pre-existing datasets, but realised that most of the datasets were either too large, or too complex for our purposes, therefore we decided to create our own dataset. We wanted to create a small, simple dataset, and additionally we wanted to get a better understanding of how \gls{rdf} worked. The dataset was made in a .t
We based the dataset on Pokemon, for no particular reason, other than it being easy for us all to understand and relate to. We created a dataset with the first 151 pokemon, where each pokemon had a name, one or two types, a number, and a relationship to other Pokemon that it evolves to. We felt this was a good representation of the concept of \gls{rdf}.





%Notes
%What is the difference between a graph database and a triple store?
%Why we created our own dataset

% @online{docker_install,
%     author  = {Docker},
%     url     = {https://www.docker.com/},
%     urldate = {2023-04-06},
% }