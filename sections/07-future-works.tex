\section{Future Works}\label{sec:future-works}
Because the data does not cover query sizes above 8000, it is not possible to compare the performance of the dynamic updating method when the dataset is small relative to the query size, and it would be interesting to collect data on this. Based on the data collected, assuming a steady increase in running time, it is expected to perform poorly, but this is conjecture.

It would also be interesting to explore the difference in running time using more varied data. The data used in this paper is plain and similar, having only two different densities of triples. Furthermore, there is no exploration of the state of the database before and after each query, which makes a big difference in the choice of whether to update or regenerate a \gls{void} description for a dataset. For example, suppose an insert query is run twice. In that case, it should not be necessary to regenerate the \gls{void} description twice, as the second time, the \gls{void} description should be up to date, which is not explored in this paper. However, exploring this kind of analysis in future works would be interesting.

The scope of this paper is relatively limited, exploring only a small subset of \gls{void} properties and only one type of query. Further research could explore other types of queries, such as delete and update queries or more advanced insert queries, as well as other \gls{void} properties. In addition, class- and property partitions look particularly interesting, as these could be used to effectivize linkset queries.

It has not been mentioned as a parameter for the experiment, but the database implementation might be a relevant factor. Aside from not having access to the internals of the database, the implementation of GraphDB may also be a factor in the execution time of the queries. Therefore, performing the same experiments on different database implementations, for example, Virtuoso, Blazegraph, or Apache Jena, may yield different results.