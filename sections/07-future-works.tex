\section{Future Works}\label{sec:future-works}
Because the data in the experiments do not cover query sizes above 8000, it is not possible to compare the performance of the dynamic updating method when the dataset is small relative to the query size, and it would be interesting to collect data on this. Based on the data collected, assuming a steady increase in running time, it is expected to perform poorly, but this is conjecture.

The scope of this paper is relatively limited, exploring only a small subset of \gls{void} properties and only one type of query. Further research could explore other types of queries, such as delete and update queries or more advanced insert queries, as well as other \gls{void} properties.

As mentioned in \autoref{sec:update-void-query}, the current implementation of the update method can be extended to support property partitioning. This is very relevant because it would enable the more efficient joins of the dataset and add even more relevant statistics to the \gls{void} description.

Also, exploring different variations of the query used in the update method is worth looking into. It may be that there is a more efficient query structure to generate based on the insert query, and determining the most efficient query structure is worth exploring.

It has not been mentioned as a parameter for the experiment, but the database implementation might be a relevant factor. Aside from not having access to the internals of the database, the implementation of GraphDB may also be a factor in the execution time of the queries. Therefore, performing the same experiments on different database implementations, for example, Virtuoso~\cite{virtuoso}, Blazegraph~\cite{blazegraph}, or Apache Jena~\cite{apache-jena}, may yield different results.