\section{Summary}\label{sec:summary}
The article discusses the use of \gls{rdf} and \gls{void} in the Semantic Web. It proposes a solution for dynamically generating and updating \gls{void} descriptions for \gls{rdf} datasets to optimize federated queries. It also explains the challenges in keeping \gls{void} descriptions up-to-date and highlights the lack of a standard way to provide approximate numbers for statistics in \gls{void}. It is then described how the tool GraphDB, an \gls{rdf} triple store, was chosen as the database management system due to its ability to use \gls{sparql} for querying data.

One dataset was used, the WatDiv dataset containing 10 million triples. The dataset was used for test generating and updating a \gls{void} description. The WatDiv dataset was split into ten smaller datasets, and the initial database creation was made using one split of 1 million tripels.

In contrast, the other nine were used to insert data into the database in the experiment. First, the \gls{void} description was generated using the \gls{sparql} query language. The \gls{void} description was then updated by inserting the data from the other nine splits into the database. The generation and update times were measured for different databases and query sizes ten times for consistent results.

The article then presents the results of generating and updating \gls{void} descriptions for \gls{rdf} databases by displaying the generation and update times for different database and query sizes in graphs.

The generation results measured the time it took to generate \gls{void} descriptions for different database sizes. The results showed a linear increase in generation time as the database size increased. However, outliers were observed in the first few runs of the experiment; this was likely due to external factors affecting the measurements. Removing the outliers revealed a stable trend in the generation time.

The update results measured the time it took to update \gls{void} descriptions for different query and database sizes. The query size significantly impacted the update time, while the database size had a minimal effect. The results suggested that as the query size increased, the update time also increased.

A comparison was made between the generation and update times based on the database size. It was observed that generating a \gls{void} description took significantly longer as the database size increased, while the update time remained relatively unaffected by the database size. This indicated that it was more efficient for more extensive databases to update the \gls{void} description rather than generating it from scratch. However, generating the \gls{void} description from scratch was more practical for smaller databases.

Overall, the results highlighted the importance of query size in the update process and suggested avenues for future research, such as investigating the influence of data structure on update times.

The dynamic update method is beneficial when a database grows over time, and the owner wants to maintain an up-to-date \gls{void} description without manual intervention. Automating the update process saves time and effort for the owner and ensures that users can rely on an accurate \gls{void} description. The choice between dynamic update and regeneration methods depends on factors such as database size and the anticipated updates it will receive. The regeneration method may be preferred for small databases due to its faster execution.

The article concludes that it is possible and, at some times, beneficial to use a dynamic update method to update the \gls{void} description of an \gls{rdf} dataset run in a GraphDB database. However, depending on the factors measured, such as database and query size, there are times when it is better suited to generate a \gls{void} description. Therefore, it is essential to consider the trade-off between the computational cost of making a new \gls{void} description and the benefits of having an updated \gls{void} description when updating a database.

The study identifies a ratio between the database's size and the query's size to be inserted, which influences the optimal method. When the database is relatively large compared to the query, updating the \gls{void} description based on relevant changes is more efficient than generating it from scratch. Conversely, when the database is relatively small compared to the query, generating the \gls{void} description is more efficient.

However, there are edge cases that the results do not directly address, such as when the database and query sizes are similar or when the query is significantly larger than the database. These cases warrant further investigation to gain deeper insights. It should be noted that the results are based on the assumption that only new data is inserted into the database.
